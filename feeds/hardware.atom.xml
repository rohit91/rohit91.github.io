<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Rohit's Blog - Hardware</title><link href="https://rohitksingh.in/" rel="alternate"></link><link href="https://rohitksingh.in/feeds/hardware.atom.xml" rel="self"></link><id>https://rohitksingh.in/</id><updated>2018-05-09T22:58:00+05:30</updated><entry><title>FTDI Asynchronous FIFO USB Communication With FPGA</title><link href="https://rohitksingh.in/ftdi-asynchronous-fifo-usb-communication-with-fpga.html" rel="alternate"></link><published>2016-08-20T10:10:00+05:30</published><updated>2018-05-09T22:58:00+05:30</updated><author><name>Rohit</name></author><id>tag:rohitksingh.in,2016-08-20:/ftdi-asynchronous-fifo-usb-communication-with-fpga.html</id><summary type="html">&lt;p&gt;In this article, we walk through technical details of FTDI's Asynchronous FIFO interface which is necessary for this project, then we will proceed to the designing part where we design the FSM (or, algorithm in software parlance), and after that we simply implement our designed FSM in VHDL. Once VHDL coding is done, we verify our design through simulation. Finally, we test our design on hardware and benchmark the performace i.e, the transfer rate achieved.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;I've had a Saturn board lying around for a long time. It's a nice board with &lt;strong&gt;Spartan 6&lt;/strong&gt; series &lt;strong&gt;LX9&lt;/strong&gt; FPGA in CSG324 package, &lt;strong&gt;512Mbits LPDDR&lt;/strong&gt; memory which can run at upto &lt;strong&gt;166MHz&lt;/strong&gt; and &lt;strong&gt;lots&lt;/strong&gt; of IOs. And it also has an &lt;strong&gt;FT2232H&lt;/strong&gt; IC on it. &lt;/p&gt;
&lt;p&gt;FT2232H is an interesting chip from FTDI, the manufacturer of well known USB-Serial ICs. It has 2 independent serial/FIFO channels, &lt;strong&gt;Channel A&lt;/strong&gt; and &lt;strong&gt;Channel B&lt;/strong&gt;. Each of these channels can be configured into various modes like UART, FIFO, JTAG, SPI, I2C etc. For Saturn, Channel A of FT2232H is reserved for FPGA configuration and flash programming. Channel B is generally used by user for UART communication. One thing to point out is that in Saturn, the control bus of Channel A is brought out to header, so we can use it for whatever purpose we desire.&lt;/p&gt;
&lt;p&gt;In this article, we walk through technical details of FTDI's Asynchronous FIFO interface which is necessary for this project, then we will proceed to the designing part where we design the FSM (or, algorithm in software parlance), and after that we simply implement our designed FSM in VHDL. Once VHDL coding is done, we verify our design through simulation. Finally, we test our design on hardware and benchmark the performace i.e, the transfer rate achieved.&lt;/p&gt;
&lt;h2&gt;FIFO Communication&lt;/h2&gt;
&lt;p&gt;FIFO is a common way of communication between two devices, specially if they are running at different speeds. &lt;/p&gt;
&lt;h3&gt;FT2232H FIFO Modes&lt;/h3&gt;
&lt;p&gt;FT2232H has two FIFO modes that a user can use for his/her purpose:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Synchronous FIFO mode&lt;/li&gt;
&lt;li&gt;Asynchronous FIFO mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Synchronous FIFO mode can push data at much faster rate. All signals in this mode are driven synchronous with the 60MHz clock sourced from FTDI itself. [marcan] reports having achieved 42MB/s of transfer rates with synchronous FIFO Mode [1].  Whereas, asynchronous FIFO mode can only transfer data at quite lower rate, because, well its asynchronous! &lt;/p&gt;
&lt;p&gt;All points go in favour of synchronous FIFO mode, only except the fact that synchronous mode can only be used with Channel A of FT2232 and that in my Saturn board, Channel A is unfortunately unavailable to user because it is dedicated for FPGA configuration and flash programming. That leaves us Channel B of FT2232H available for use. But it only supports asynchronous FIFO mode. Bummer!&lt;/p&gt;
&lt;p&gt;So what if we only have the choice of asynchronous mode with us! We can still transfer data from PC to FPGA over USB at reasonably good speed. People have achieved over 14MB/s transfer rate using this mode. So lets take a detailed look at it before we try writing VHDL code for it.&lt;/p&gt;
&lt;h3&gt;Asynchronous FIFO Mode&lt;/h3&gt;
&lt;p&gt;FT2232H datasheet[2] has a some details on asynchronous mode. Let's first check out the pins/signals used for interfacing using this mode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pins:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BDBUS[7:0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;D7 to D0 directional FIFO data. This bus is normally input unless RD# is low&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RXF#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OUTPUT&lt;/td&gt;
&lt;td&gt;When high, do not read data from the FIFO. When low, there is data available in the FIFO which can be read by driving RD# low. When RD# goes high again RXF# will always go high and only become low again if there is another byte to read. During reset, this signal is tri-state, but pulled up to VCCIO via an internal 200k ohms resistor.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TXE#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OUTPUT&lt;/td&gt;
&lt;td&gt;When high, do not write data into the FIFO. When low, data can be written into the FIFO by strobing WR# high, then low. During reset this signal is tri-state, but pulled up to VCCIO via an internal 200k ohms resistor.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RD#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INPUT&lt;/td&gt;
&lt;td&gt;Enables the current FIFO data byte to be driven onto D0...D7 when RD# goes low. Fetches the next FIFO data byte (if available) from the receive FIFO buffer when RD# goes high.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WR#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INPUT&lt;/td&gt;
&lt;td&gt;Writes the data byte on the D0...D7 pins into the transmit buffer when WR# goes from high to low.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Read Timing Diagram:&lt;/strong&gt; 
&lt;img alt="Read" src="https://rohitksingh.in/images/ftdi-async-fifo/read_timing_diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Timing Diagram:&lt;/strong&gt;
&lt;img alt="Write" src="https://rohitksingh.in/images/ftdi-async-fifo/write_timing_diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timing Parameters:&lt;/strong&gt;
&lt;img alt="Timings" src="https://rohitksingh.in/images/ftdi-async-fifo/timing_parameters.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(All images above are from FT2232H Datasheet)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Design&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Before doing anything, first we need to understand the timing diagrams shown above. Then we need to design our FSM as per our requirements. And finally, simply implement our FSM using either VHDL or Verilog or Migen. We'll be using VHDL for this article.&lt;/p&gt;
&lt;h3&gt;Demostration Goal&lt;/h3&gt;
&lt;p&gt;The high-level goal of this article is to implement Asynchronous FIFO based communication between FPGA and FTDI FT2232H over USB. And how exactly will we be demonstrating this? For that, we need a low-level goal defined. Let's just decide for this article, that we will be sending stream of data to the FTDI FT2232H over USB, and our FPGA board needs to read every byte of data from the stream, then increment the byte it just read, and finally send it back to our host PC via the same FT2232 chip using Asynchronous FIFO interface.&lt;/p&gt;
&lt;h3&gt;Understanding Timing Diagrams&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Signals with &lt;code&gt;#&lt;/code&gt; in their name are active-low signals. That means, they are active when low, and inactive when high. Asserting an active-low signal means driving them low. Deasserting an active-low signal means driving them back to high, their inactive state.&lt;/p&gt;
&lt;p&gt;When we send a byte of data from host PC over USB, to FTDI FT2232H IC, it gets stored in its internal receiver FIFO. We give commands through control sigals to read that data. Similarly, for sending something to host PC, we first write that data into FT2232H's transmitter FIFO, after which FT2232H automatically handles sending it to host PC over USB channel. &lt;/p&gt;
&lt;h5&gt;Read Timings:&lt;/h5&gt;
&lt;p&gt;Whenever FT2232H has data available for reading in its FIFO, it asserts the &lt;strong&gt;&lt;code&gt;RXF&lt;/code&gt;&lt;/strong&gt; signal (drives it low since it is an active-low signal). This indicates to the user that FT2232H has some data available from host PC in its receiver FIFO, and that user is now free to read it whenever he/she wants to. &lt;/p&gt;
&lt;p&gt;Now, for actually reading the data from FT2232H's FIFO, user has to assert the &lt;strong&gt;&lt;code&gt;RD&lt;/code&gt;&lt;/strong&gt; signal (drive it low). From the timing diagram and the timing parameters table, we find that user is free to assert &lt;code&gt;RD&lt;/code&gt; signal as soon as &lt;code&gt;RXF&lt;/code&gt; is active (parameterized by &lt;strong&gt;&lt;code&gt;t5&lt;/code&gt;&lt;/strong&gt; parameter in the table).&lt;/p&gt;
&lt;p&gt;After the user has driven &lt;code&gt;RD&lt;/code&gt; signal low, he/she isn't supposed to read the data on &lt;strong&gt;&lt;code&gt;DATA[7:0]&lt;/code&gt;&lt;/strong&gt; lines instantly because there is no valid data on those lines! This is because FT2232H takes some time to fetch data from its receiver FIFO and put it on &lt;code&gt;DATA[7:0]&lt;/code&gt; lines after &lt;code&gt;RD&lt;/code&gt; is asserted. This time is parameterized by &lt;strong&gt;&lt;code&gt;t3&lt;/code&gt;&lt;/strong&gt; parameter. The table says, &lt;code&gt;t3&lt;/code&gt; can be minimum 1ns to maximum 14ns. In digital designs, we design our systems according to worst-case situations. And here, the table says that in worst case, it may take for FT2232H almost 14ns to put data onto &lt;code&gt;DATA[7:0]&lt;/code&gt; lines after we assert &lt;code&gt;RD&lt;/code&gt; signal. So, to be always on safe side, we should read &lt;code&gt;DATA[7:0]&lt;/code&gt; atleast 14ns after we have asserted &lt;code&gt;RD&lt;/code&gt; signal. &lt;/p&gt;
&lt;p&gt;Now, 14ns is some uncomfortable time duration for us, because Saturn has 100MHz clock oscillator. Which means we have resolution of only 10ns. [Note: Its not that simple though, there are many ways to improve this resolution. But for this article, let's just go simple way] This means we can count in multiples of 10ns. So we have to wait for minimum 2 clock cycles (20ns) before reading &lt;code&gt;DATA[7:0]&lt;/code&gt; lines. Please note that there is no maximum time limit for us to read the data. We are free to read it after 20ns, 30ns, 40ns etc. Any duration after 14ns is perfectly okay. &lt;/p&gt;
&lt;p&gt;After reading data from &lt;code&gt;DATA[7:0]&lt;/code&gt; lines, we have to deassert the &lt;code&gt;RD&lt;/code&gt; signal so FT2232H can know that we have successfully read that data which it had put on &lt;code&gt;DATA[7:0]&lt;/code&gt; lines and now it can remove that data from its FIFO. But, there is one more catch! We can't deassert &lt;code&gt;RD&lt;/code&gt; signal anytime. The timing parameter table says that active width of &lt;code&gt;RD&lt;/code&gt; should be atleast 30ns. So if for example we were to read &lt;code&gt;DATA[7:0]&lt;/code&gt; after 20ns of asserting &lt;code&gt;RD&lt;/code&gt;, which is allowed, and if we then immediately deassert &lt;code&gt;RD&lt;/code&gt;, it will result in violation of timings specifications, since &lt;code&gt;RD&lt;/code&gt; has been active only for 20ns! So in this case, we should wait atleast 10ns more after reading data from DATA[7:0] lines before deasserting &lt;code&gt;RD&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After deasserting &lt;code&gt;RD&lt;/code&gt; properly, we are done for the reading part! We don't need to care about anything else. FT2232H will handle rest for read part. &lt;/p&gt;
&lt;p&gt;This whole process needs to be repeated to every byte that we want to read. For every byte, it starts with &lt;code&gt;RXF&lt;/code&gt; being asserted by FTDI and ends with &lt;code&gt;RD&lt;/code&gt; being deassserted by the user after which FT2232H automatically deasserts &lt;code&gt;RXF&lt;/code&gt; also after some time (check timing diagram).&lt;/p&gt;
&lt;h5&gt;Write Timings:&lt;/h5&gt;
&lt;p&gt;Write process starts with FT2232H asserting &lt;code&gt;TXE&lt;/code&gt; signal indicating that it is now ready to accept data from the user which needs to be transmitted to host PC over USB.&lt;/p&gt;
&lt;p&gt;Although timing parameters table says that user can assert &lt;code&gt;WR&lt;/code&gt; signal as soon as &lt;code&gt;TXE&lt;/code&gt; is asserted by FT2232H, but in fact this is not allowed. There is one more catch! &lt;/p&gt;
&lt;p&gt;For valid trasmission, user needs to put the data which is to be transmitted onto &lt;code&gt;DATA[7:0]&lt;/code&gt; lines for &lt;code&gt;t8&lt;/code&gt; duration which is 5ns (also called setup time) before asserting &lt;code&gt;WR&lt;/code&gt; and user also needs to keep/hold the data there for &lt;code&gt;t9&lt;/code&gt; duration which is again 5ns (also called hold time). &lt;/p&gt;
&lt;p&gt;FT2232H will deassert &lt;code&gt;TXE&lt;/code&gt; signal at maximum 14ns after &lt;code&gt;WR&lt;/code&gt; is asserted by user. He/she needs to make sure that FT2232 has captured proper data by keeping the &lt;code&gt;t8&lt;/code&gt; and &lt;code&gt;t9&lt;/code&gt; timings mentioned in previous paragraph.&lt;/p&gt;
&lt;p&gt;Same as for &lt;code&gt;RD&lt;/code&gt; signal, &lt;code&gt;WR&lt;/code&gt; also needs to be asserted for atleast 30ns before it can be deasserted by user. In our case, that means 3 clock cycles (100MHz clock, remember?).&lt;/p&gt;
&lt;p&gt;As in case for read process, this process also needs to be repeated for every byte that we transmit.&lt;/p&gt;
&lt;h3&gt;TL;DR: Timings &amp;amp; Interfacing&lt;/h3&gt;
&lt;h5&gt;Read process:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;Wait till &lt;code&gt;RXF&lt;/code&gt; is asserted (i.e, is driven low by FT2232)&lt;/li&gt;
&lt;li&gt;Assert &lt;code&gt;RD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Read data from &lt;code&gt;DATA[7:0]&lt;/code&gt; lines after atleast 14ns &lt;/li&gt;
&lt;li&gt;Deassert &lt;code&gt;RD&lt;/code&gt; after atleast 30ns of its assertion&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Write process:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;Wait till &lt;code&gt;TXE&lt;/code&gt; is asserted&lt;/li&gt;
&lt;li&gt;Put data to transmit onto &lt;code&gt;DATA[7:0]&lt;/code&gt; bus&lt;/li&gt;
&lt;li&gt;Wait for atleast 5ns&lt;/li&gt;
&lt;li&gt;Assert &lt;code&gt;WR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hold the same data onto &lt;code&gt;DATA[7:0]&lt;/code&gt; bus for atleast another 5ns&lt;/li&gt;
&lt;li&gt;Deassert &lt;code&gt;WR&lt;/code&gt; after atleast 30ns of its assertion&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;FSM Design&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;READ_IDLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Wait for &lt;code&gt;RXF&lt;/code&gt; assertion. If &lt;code&gt;RXF&lt;/code&gt; is asserted, assert &lt;code&gt;RD&lt;/code&gt; and go to &lt;code&gt;READ_PREWAIT&lt;/code&gt; state.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;READ_PREWAIT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Wait for 2 clock cycles (20ns) then read data and go to &lt;code&gt;READ_POSTWAIT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;READ_POSTWAIT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Wait for 2 clock cycles (20ns), deassert &lt;code&gt;RD&lt;/code&gt; and the go to &lt;code&gt;WRITE_IDLE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WRITE_IDLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Wait for &lt;code&gt;TXE&lt;/code&gt; assertion. If &lt;code&gt;TXE&lt;/code&gt; is asserted, put data onto DATA[7:0] bus and go to &lt;code&gt;WRITE_PREWAIT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WRITE_WAIT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;By the time we check that we are into &lt;code&gt;WRITE_WAIT&lt;/code&gt; state, 1 clock cycle (10ns) has already elasped. So there is no particular requirement to wait for 5ns. So, just assert &lt;code&gt;WR&lt;/code&gt; now and and wait for 3 clock cycles and move to &lt;code&gt;WRITE_DONE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WRITE_DONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Deassert &lt;code&gt;WR&lt;/code&gt; and go to &lt;code&gt;READ_IDLE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;: &lt;strong&gt;Do not&lt;/strong&gt; check for falling edge in above FSM! Instead, check for level. &lt;code&gt;RXF&lt;/code&gt; and &lt;code&gt;TXE&lt;/code&gt; might have already had their falling edge before you check for them, so your FSM gets stuck in IDLE state forever, because those &lt;code&gt;RXF&lt;/code&gt; and &lt;code&gt;TXE&lt;/code&gt; will never go high until you read/write but your code won't read/write since it is still in &lt;code&gt;IDLE&lt;/code&gt; state waiting for falling edge which has already occurred and which won't occur again unless a read/write transaction is made! I initially made this same mistake, and most of the times my design would work but randomly fail after I would have transferred some number of bytes. It took sometime to figure out this bug!&lt;/p&gt;
&lt;h3&gt;Code&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;: All files related to this project are available in my github repository: &lt;a href="https://github.com/rohitk-singh/ftdi-async-fifo"&gt;https://github.com/rohitk-singh/ftdi-async-fifo&lt;/a&gt;&lt;/em&gt; &lt;/p&gt;
&lt;h4&gt;VHDL&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;--------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;-- Author  : Rohit Singh&lt;/span&gt;
&lt;span class="c1"&gt;-- Module  : ft2232h - rtl&lt;/span&gt;
&lt;span class="c1"&gt;-- Project : FT2232H Async FIFO&lt;/span&gt;

&lt;span class="c1"&gt;-- License : The MIT License&lt;/span&gt;
&lt;span class="c1"&gt;-- Copyright © 2015, 2016, 2017, 2018 Rohit K. Singh (contact [AT] rohitksingh.in)&lt;/span&gt;
&lt;span class="c1"&gt;--------------------------------------------------------------------------------&lt;/span&gt;

&lt;span class="k"&gt;library&lt;/span&gt; &lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;IEEE.STD_LOGIC_1164.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;IEEE.NUMERIC_STD.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;ft2232h&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;clk&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rst&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;-- FTDI FT2232H FIFO signals&lt;/span&gt;
        &lt;span class="n"&gt;data&lt;/span&gt;  &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;inout&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;rxf_n&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;txe_n&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rd_n&lt;/span&gt;  &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt;   &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;wr_n&lt;/span&gt;  &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt;   &lt;span class="kt"&gt;std_logic&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;ft2232h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;rtl&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;ft2232h&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;data_o&lt;/span&gt;             &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;data_i&lt;/span&gt;             &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;data_en&lt;/span&gt;            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;rxf_n_meta&lt;/span&gt;            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;txe_n_meta&lt;/span&gt;            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;rxf_n_sync&lt;/span&gt;            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;txe_n_sync&lt;/span&gt;            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;rd_n_q&lt;/span&gt;                &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;wr_n_q&lt;/span&gt;                &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;            &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;reg&lt;/span&gt;      &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RD_IDLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RD_PRE_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RD_POST_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WR_IDLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WR_WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WR_DONE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;RD_IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;  &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;begin&lt;/span&gt;

    &lt;span class="c1"&gt;-- Bi-directional logic&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;     &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data_o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;data_en&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;data_i&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;rd_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rd_n_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;wr_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;wr_n_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;-- Avoid metastability. Synchronize async signals  RXF and TXE&lt;/span&gt;
    &lt;span class="nc"&gt;synchronizer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;rising_edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="n"&gt;rxf_n_meta&lt;/span&gt;            &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rxf_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;txe_n_meta&lt;/span&gt;            &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;txe_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;rxf_n_sync&lt;/span&gt;            &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rxf_n_meta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;txe_n_sync&lt;/span&gt;            &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;txe_n_meta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nc"&gt;main&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;RD_IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;rd_n_q&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;wr_n_q&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;elsif&lt;/span&gt; &lt;span class="n"&gt;rising_edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;RD_IDLE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;rxf_n_sync&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
                        &lt;span class="n"&gt;rd_n_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;state&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;RD_PRE_WAIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;RD_PRE_WAIT&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;01&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
                        &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;RD_POST_WAIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;data_i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;RD_POST_WAIT&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;01&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
                        &lt;span class="n"&gt;rd_n_q&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;WR_IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;WR_IDLE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;txe_n_sync&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
                        &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;WR_WAIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;data_o&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;data_en&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;WR_WAIT&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="n"&gt;wr_n_q&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;11&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
                        &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;WR_DONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;data_en&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

                &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;WR_DONE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
                    &lt;span class="n"&gt;wr_n_q&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;state&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;RD_IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;rtl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Simulation&lt;/h2&gt;
&lt;p&gt;Let's see how my above design responds to my rudimentary testbench (Yeah, I suck at writing good tests)&lt;/p&gt;
&lt;h4&gt;RD# active after RXF# assertion&lt;/h4&gt;
&lt;p&gt;&lt;img alt="RXF# to RD# delay" src="https://rohitksingh.in/images/ftdi-async-fifo/rxf_to_rd_delay.png"&gt;&lt;/p&gt;
&lt;p&gt;From the image above, we see that time delay between &lt;code&gt;RXF#&lt;/code&gt; going low to &lt;code&gt;RD#&lt;/code&gt; driven low by code is &lt;code&gt;25ns&lt;/code&gt;. Datasheet says it can be as low as &lt;code&gt;0ns&lt;/code&gt;. For fastest data transfer rate, it should ideally be 0ns. In real-world, this delay will vary from 20ns to 30ns, which comes from our current VHDL code.&lt;/p&gt;
&lt;h4&gt;RD# asserted to reading data&lt;/h4&gt;
&lt;p&gt;&lt;img alt="RD# asserted to reading delay" src="https://rohitksingh.in/images/ftdi-async-fifo/rd_to_read.png"&gt;&lt;/p&gt;
&lt;p&gt;From the above snip, we see that time delay from &lt;code&gt;RD#&lt;/code&gt; driven low to actually reading data (check &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;reg[7:0]&lt;/code&gt; signals) is &lt;code&gt;20ns&lt;/code&gt;. Datasheet specified atleast &lt;code&gt;14ns&lt;/code&gt; delay so we are good here also.&lt;/p&gt;
&lt;h4&gt;RD# pulse width&lt;/h4&gt;
&lt;p&gt;&lt;img alt="RD# pulse width" src="https://rohitksingh.in/images/ftdi-async-fifo/rd_pulse_width.png"&gt;&lt;/p&gt;
&lt;p&gt;While datasheet says that minimum &lt;code&gt;RD#&lt;/code&gt; pulse width should be &lt;code&gt;30ns&lt;/code&gt;, we are quite safe here with pulse width of &lt;code&gt;40ns&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Write data setup time&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Write data setup time" src="https://rohitksingh.in/images/ftdi-async-fifo/write_data_setup_time.png"&gt;&lt;/p&gt;
&lt;p&gt;We put tx-data on &lt;code&gt;DATA[7:0]&lt;/code&gt; lines &lt;code&gt;10ns&lt;/code&gt; before driving &lt;code&gt;WR#&lt;/code&gt; low. So that satisfies datasheet's minimum requirement of &lt;code&gt;5ns&lt;/code&gt;. We can notice here that &lt;code&gt;a5&lt;/code&gt; was read, and we are transmitting its incremented value i.e, &lt;code&gt;a6&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;WR# pulse width&lt;/h4&gt;
&lt;p&gt;&lt;img alt="WR# pulse width" src="https://rohitksingh.in/images/ftdi-async-fifo/wr_pulse_width.png"&gt;&lt;/p&gt;
&lt;p&gt;Same as in case of &lt;code&gt;RD#&lt;/code&gt; signal, datasheet specifies minimum pulse width of &lt;code&gt;30ns&lt;/code&gt; and we are again on safe side with pulse width of &lt;code&gt;40ns&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, our VHDL design seems to be working well in simulation. Its time to try it on actual hardware!&lt;/p&gt;
&lt;h2&gt;Running On Hardware&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;: All files related to this project are available in my github repository: &lt;a href="https://github.com/rohitk-singh/ftdi-async-fifo"&gt;https://github.com/rohitk-singh/ftdi-async-fifo&lt;/a&gt;&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;Clone/download my repository, then open the .xise project file in Xilinx ISE and build it. You might need to modify constraints in .ucf file if your board/schematic is different. Program the FPGA with generated bitstream and we are ready to test.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build project in Xilinx ISE" src="https://rohitksingh.in/images/ftdi-async-fifo/ise_build.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(No warnings, Yeah! That's very rare in Xilinx ISE :p )&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Test Setup&lt;/h3&gt;
&lt;p&gt;We need some way of sending data from host PC to FTDI, and reading data received from FTDI on host PC. The FTDI-FPGA part is handled by our design running on the FPGA.&lt;/p&gt;
&lt;p&gt;There are many ways to do this on Linux and Windows. But, I'll go with my own setup.&lt;/p&gt;
&lt;p&gt;I'll use Linux, Ubuntu 14.04 to be precise. I'll use &lt;code&gt;Python&lt;/code&gt; with &lt;a href="https://pylibftdi.readthedocs.io/en/0.15.0/"&gt;&lt;code&gt;pylibftdi&lt;/code&gt;&lt;/a&gt; library to send/receive data to/from FTDI. &lt;/p&gt;
&lt;p&gt;So, for this test setup, you'll need:
1. Linux Host
2. Python (already comes with most Linux distributions)
3. &lt;code&gt;pylibftdi&lt;/code&gt; library properly set up and working&lt;/p&gt;
&lt;p&gt;Using pylibftdi, it's just a simple, few-lines-of-code job to test our project! So let's fire up python!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pylibftdi&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Driver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Device&lt;/span&gt;

&lt;span class="c1"&gt;# Get list of all FTDI devices&lt;/span&gt;
&lt;span class="n"&gt;dev_list&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Driver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list_devices&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Print all devices&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;device_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dev_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;device_&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(&amp;#39;FTDI&amp;#39;, &amp;#39;Saturn Spartan 6 FPGA Module&amp;#39;, &amp;#39;FTZ17IRO&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Above code lists out all FTDI ICs detected by the &lt;code&gt;pylibftdi&lt;/code&gt; library. We can see my Saturn board has been detected by it. &lt;/p&gt;
&lt;p&gt;Now let's open this device, write something to it and read back same number of bytes to test if our VHDL design for FTDI Asynchronous FIFO communication is working fine or not.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Create Device instance: Channel B in binary mode&lt;/span&gt;
&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Device&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;device_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;FTZ17IRO&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;interface_select&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Open the instantiated device&lt;/span&gt;
&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Write value 16 to FTDI over USB, returns number of bytes written&lt;/span&gt;
&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bytearray&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,]))&lt;/span&gt;

&lt;span class="c1"&gt;# Read one byte&lt;/span&gt;
&lt;span class="n"&gt;rx_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="nb"&gt;bytearray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# Print the byte received. Should be 16+1 i.e, 17&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;rx_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# Close device after use&lt;/span&gt;
&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;17
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yes! Our design is working! We sent 16 and received 17 as expected! Check the screenshot below for actual proof!
&lt;img alt="Simple Python test" src="https://rohitksingh.in/images/ftdi-async-fifo/python_simple_test.png"&gt;&lt;/p&gt;
&lt;h2&gt;Performance &amp;amp; Benchmarking&lt;/h2&gt;
&lt;p&gt;In the last section, we just did a simple test. We sent one byte, received one byte and verified whether the received byte was indeed incremented by one or not. But, this is not sufficient to prove the reliability of our design. &lt;/p&gt;
&lt;p&gt;We need to do more rigorous testing to prove that our design works reliably. In this section we will subject our design to much more data than just 1 byte! Let's see my simple benchmarking code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#! /usr/bin/python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pylibftdi&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Driver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Device&lt;/span&gt;

&lt;span class="n"&gt;dev_list&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Driver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list_devices&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dev_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Following devices found:&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;device_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dev_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;device_&lt;/span&gt;

&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Device&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;device_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;FTZ17IRO&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;interface_select&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="n"&gt;epochs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;BLOCK_LEN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2048&lt;/span&gt;
&lt;span class="n"&gt;tx_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;bytearray&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BLOCK_LEN&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;epochs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tx_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;rx_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;bytearray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BLOCK_LEN&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;#print &amp;quot;Epoch: {}&amp;quot;.format(epochs) &lt;/span&gt;
    &lt;span class="n"&gt;failed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BLOCK_LEN&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;tx_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;rx_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Epoch: {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epochs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[Test]: Data verification failed! , tx_data : &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tx_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; =/= rx_data : &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rx_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;failed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Breaking...&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;failed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;

    &lt;span class="n"&gt;epochs&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;te&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Time {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;te&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This code will send a random generated block of data of length &lt;code&gt;BLOCK_LEN&lt;/code&gt; total of &lt;code&gt;10240&lt;/code&gt; times and verify whether we have received expected data or not. I've chosen BLOCK_LEN to be &lt;code&gt;2048&lt;/code&gt;, so in total we are sending 20MB (Mega Bytes) of data to the FPGA, which is quite a large amount! We are also receiving &lt;code&gt;20MB&lt;/code&gt; of data and verifying its correctness. We will also measure the time it takes to complete the whole operation.&lt;/p&gt;
&lt;p&gt;Code runs successfully without any verification error! And we get the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Following devices found:
(&amp;#39;FTDI&amp;#39;, &amp;#39;Saturn Spartan 6 FPGA Module&amp;#39;, &amp;#39;FTZ17IRO&amp;#39;)
Time 10.9798371792
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Single Benchmark" src="https://rohitksingh.in/images/ftdi-async-fifo/benchmark_single.png"&gt;&lt;/p&gt;
&lt;p&gt;That's around &lt;code&gt;1.8 MB/s&lt;/code&gt; transfer rate considering only transmitted data! If we take into account data in both directions, then transfer rate is actually twice of that, i.e, around &lt;code&gt;3.6 MB/s&lt;/code&gt;! That's quite satisfactory performance for me. We can improve it further by using C/C++ interface and squeezing the VHDL code further! Nevertheless, I'm very much satisfied with this transfer rate! :)&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This project was quite interesting to me, as I wanted to see for myself how can I use FTDI's Asynchronous FIFO interface. In this article, we went into some basic theory, then designed our FSM/algorithm based on that theory, implemented it in VHDL, simulated it, and finally ran it on hardware. We did proof-of-concept tests and benchmarks on our design. And, yeah we achieved &lt;code&gt;1.8 MB/s&lt;/code&gt; transfer rate! I hope my readers also find this article interesting! :)&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.eevblog.com/forum/microcontrollers/ftdi-ft232h-in-synchronous-fifo-questions/msg671602/#msg671602"&gt;http://www.eevblog.com/forum/microcontrollers/ftdi-ft232h-in-synchronous-fifo-questions/msg671602/#msg671602&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf"&gt;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="ftdi"></category><category term="ft2232"></category><category term="fifo"></category><category term="usb"></category><category term="vhdl"></category><category term="verilog"></category><category term="fpga"></category><category term="asynchronous fifo"></category><category term="migen"></category><category term="electronics"></category><category term="hardware"></category></entry></feed>